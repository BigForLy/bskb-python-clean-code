# bskb-python-clean-code

# Инструкция assert

Инструкции призваны быть внутренними самопроверками (internal selfchecks) вашей программы. Они работают путем объявления неких условий, возникновение которых в вашем исходном коде невозможно. Если
одно из таких условий не сохраняется, то это означает, что в программе
есть ошибка.
Конструкция:
```
инструкция_assert ::= "assert" выражение1 ["," выражение2]
где выражение1 - условие, выражение2 - комментарий к ошибке
```
Пример:
```python
assert 0 <= price <= 100, "Error"
```
Ошибка:
```python
AssertionError: Error
```
Предостережение:
``` 
Не использовать assert для валидации данных!
```

# Разворачивание констант списка, словаря или множества
Плохо:
```
names = ['Элис', 'Боб', 'Дилберт']
```
Хорошо:
```python
 names = [
... 'Элис',
... 'Боб',
... 'Дилберт'
... ]
```

# Открытие файлов
Плохо:
```python
f = open('hello.txt', 'w')
f.write('привет, мир!')
f.close()
```
Вредно:
```python
f = open('hello.txt', 'w')
try:
  f.write('привет, мир!')
finally:
  f.close()
```
Хорошо:
```python
with open('hello.txt', 'w') as f:
  f.write('привет, мир!')
```

# Одинарные и двойные подчеркивания, дандеры
1. Одинарный начальный символ подчеркивания: _var
-----------

Префикс, состоящий из символа подчеркивания, подразумевается как
подсказка, которая должна сообщить другому программисту, что переменная или метод, начинающиеся с одинарного символа подчеркивания,
предназначаются для внутреннего пользования. Эта договоренность
определена в PEP 8.

Не будет работать подстановочный импорт (from my_module import *)

2. Одинарный замыкающий символ подчеркивания: var_
-----------

Иногда самое подходящее имя переменной уже занято ключевым словом
языка Python. По этой причине такие имена, как *class* или *def*, в Python
нельзя использовать в качестве имен переменных. В этом случае можно
в конец имени добавить символ одинарного подчеркивания, чтобы избежать конфликта из-за совпадения имен.  Эта договоренность
определена и объяснена в PEP 8.
