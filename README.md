# bskb-python-clean-code

# Инструкция assert

Инструкции призваны быть внутренними самопроверками (internal selfchecks) вашей программы. Они работают путем объявления неких условий, возникновение которых в вашем исходном коде невозможно. Если
одно из таких условий не сохраняется, то это означает, что в программе
есть ошибка.
Конструкция:
```
инструкция_assert ::= "assert" выражение1 ["," выражение2]
где выражение1 - условие, выражение2 - комментарий к ошибке
```
Пример:
```python
assert 0 <= price <= 100, "Error"
```
Ошибка:
```python
AssertionError: Error
```
Предостережение:
``` 
Не использовать assert для валидации данных!
```

# Разворачивание констант списка, словаря или множества
Плохо:
```
names = ['Элис', 'Боб', 'Дилберт']
```
Хорошо:
```python
 names = [
... 'Элис',
... 'Боб',
... 'Дилберт'
... ]
```

# Работа с файлами
Плохо:
```python
f = open('hello.txt', 'w')
f.write('привет, мир!')
f.close()
```
Вредно:
```python
f = open('hello.txt', 'w')
try:
  f.write('привет, мир!')
finally:
  f.close()
```
Хорошо:
```python
with open('hello.txt', 'w') as f:
  f.write('привет, мир!')
```

# Одинарные и двойные подчеркивания, дандеры

1. Одинарный начальный символ подчеркивания: _var
-----------

Префикс, состоящий из символа подчеркивания, подразумевается как
подсказка, которая должна сообщить другому программисту, что переменная или метод, начинающиеся с одинарного символа подчеркивания,
предназначаются для внутреннего пользования. Эта договоренность
определена в PEP 8.

Не будет работать подстановочный импорт (from my_module import *)

2. Одинарный замыкающий символ подчеркивания: var_
-----------

Иногда самое подходящее имя переменной уже занято ключевым словом
языка Python. По этой причине такие имена, как *class* или *def*, в Python
нельзя использовать в качестве имен переменных. В этом случае можно
в конец имени добавить символ одинарного подчеркивания, чтобы избежать конфликта из-за совпадения имен.  Эта договоренность
определена и объяснена в PEP 8.

# Использование декоратора deprecated
Если у функции есть несколько версий, необходимо каждую версию переделать в отдельную функцию. Если создается новая версия, то старую необходимо удалить или добавить декоратор deprecated, это же касается классов, неиспользуемые классы необходимо удалить или добавить декоратор.

Использование кода:
```python
from deprecated import deprecated
@deprecated(reason="use another function")
def foo():
    print('deprecated func')
```
Консоль:
```python
DeprecationWarning: Call to deprecated function (or staticmethod) foo. (use another function)
  foo()
deprecated func
```
https://github.com/tantale/deprecated

# Версионность методов
Если у метода есть несколько версий, то необходимо каждую версию выносить в отдельную функцию.

Методы для каждой версии необходимо именовать по правилам: *Coming soon*

# Правила написания JSON
Параметры JSON пишутся в стиле camelCase(должен начинаться со строчной буквы, а первая буква каждого последующего слова должна быть заглавной, все слова при этом пишутся слитно между собой.)

Плохо:
```python
{
    "method": "a",
    "params": {
      "filter_date-time": "true"
    }
}
```
Хорошо:
```python
{
    "method": "a",
    "params": {
      "filterDateTime": "true"
    }
}
```

# Создание миграций
Каждая новая миграция должна идти отдельным файлом. Но на продакшн должна уходить одна миграция, для этого необходимо использовать squashmigrations.

# Получить query запрос с параметрами
```python
str(query.statement.compile(compile_kwargs={"literal_binds": True}))
```
